
/*---------------------------------------------------------------*/
/*---                                                         ---*/
/*--- This file (x86helpers.c) is                             ---*/
/*--- Copyright (c) 2004 OpenWorks LLP.  All rights reserved. ---*/
/*---                                                         ---*/
/*---------------------------------------------------------------*/

#include "libvex_basictypes.h"
#include "libvex_ir.h"
#include "vex_util.h"
#include "x86guest_defs.h"

/* This file contains helper functions for x86 guest code.
   Calls to these functions are generated by the back end.
   These calls are of course in the host machine code and 
   this file will be compiled to host machine code, so that
   all makes sense.  

   x86guest_findhelper() is the only exported function. 

   Only change the signatures of these helper functions very
   carefully.  If you change the signature here, you'll have to change
   the parameters passed to it in the IR calls constructed by
   x86toIR.c.  
*/

typedef UChar uint8_t;

#define CC_O CC_MASK_O
#define CC_P CC_MASK_P


static const uint8_t parity_table[256] = {
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
};

/* n must be a constant to be efficient */
static inline int lshift(int x, int n)
{
    if (n >= 0)
        return x << n;
    else
        return x >> (-n);
}


#define PREAMBLE(__data_bits)						 \
   const UInt DATA_MASK 						 \
      = __data_bits==8 ? 0xFF : (__data_bits==16 ? 0xFFFF : 0xFFFFFFFF); \
   const UInt CC_DST = cc_dst;						 \
   const UInt CC_SRC = cc_src


#define ACTIONS_SUB(DATA_BITS,DATA_TYPE,DATA_STYPE)			   \
   {									   \
      PREAMBLE(DATA_BITS);						   \
      int cf, pf, af, zf, sf, of;					   \
      int src1, src2;							   \
      src1 = CC_DST + CC_SRC;						   \
      src2 = CC_SRC;							   \
      cf = (DATA_TYPE)src1 < (DATA_TYPE)src2;				   \
      pf = parity_table[(uint8_t)CC_DST];				   \
      af = (CC_DST ^ src1 ^ src2) & 0x10;				   \
      zf = ((DATA_TYPE)CC_DST == 0) << 6;				   \
      sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;			   \
      of = lshift((src1 ^ src2) & (src1 ^ CC_DST), 12 - DATA_BITS) & CC_O; \
      return cf | pf | af | zf | sf | of;				   \
   }

#define ACTIONS_LOGIC(DATA_BITS,DATA_TYPE,DATA_STYPE)	\
   {							\
      PREAMBLE(DATA_BITS);				\
      int cf, pf, af, zf, sf, of;			\
      cf = 0;						\
      pf = parity_table[(uint8_t)CC_DST];		\
      af = 0;						\
      zf = ((DATA_TYPE)CC_DST == 0) << 6;		\
      sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;	\
      of = 0;						\
      return cf | pf | af | zf | sf | of;		\
   }


/* CALLED FROM GENERATED CODE */
/*static*/ UInt calculate_eflags_all ( UInt cc_op, UInt cc_src, UInt cc_dst )
{
   switch (cc_op) {
   case CC_OP_COPY:
     return cc_src & (CC_MASK_O | CC_MASK_S | CC_MASK_Z | CC_MASK_A | CC_MASK_C | CC_MASK_O);

      case CC_OP_SUBL:   ACTIONS_SUB(32,UChar,Char);
      case CC_OP_LOGICL: ACTIONS_LOGIC(32,UChar,Char);
      default:
         /* shouldn't really make these calls from generated code */
         vex_printf("calculate_eflags_all( %d, 0x%x, 0x%x )\n",
                    cc_op, cc_src, cc_dst );
         vpanic("calculate_eflags_all");
   }
}

/* CALLED FROM GENERATED CODE */
static UInt calculate_eflags_c ( UInt cc_op, UInt cc_src, UInt cc_dst )
{
   return calculate_eflags_all(cc_op,cc_src,cc_dst) & CC_MASK_C;
}


/* The only exported function. */

Addr64 x86guest_findhelper ( Char* function_name )
{
   if (vex_streq(function_name, "calculate_eflags_all"))
      return (Addr64)(& calculate_eflags_all);
   if (vex_streq(function_name, "calculate_eflags_c"))
      return (Addr64)(& calculate_eflags_c);
   vex_printf("\nx86 guest: can't find helper: %s\n", function_name);
   vpanic("x86guest_findhelper");
}


/*---------------------------------------------------------------*/
/*--- end                                        x86helpers.c ---*/
/*---------------------------------------------------------------*/
