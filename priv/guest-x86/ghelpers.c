
/*---------------------------------------------------------------*/
/*---                                                         ---*/
/*--- This file (guest-x86/ghelpers.c) is                     ---*/
/*--- Copyright (c) 2004 OpenWorks LLP.  All rights reserved. ---*/
/*---                                                         ---*/
/*---------------------------------------------------------------*/

#include "libvex_basictypes.h"
#include "libvex_ir.h"

#include "main/vex_util.h"
#include "guest-x86/gdefs.h"

/* This file contains helper functions for x86 guest code.
   Calls to these functions are generated by the back end.
   These calls are of course in the host machine code and 
   this file will be compiled to host machine code, so that
   all makes sense.  

   x86guest_findhelper() is the only exported function. 

   Only change the signatures of these helper functions very
   carefully.  If you change the signature here, you'll have to change
   the parameters passed to it in the IR calls constructed by
   x86toIR.c.

   Some of this code/logic is derived from QEMU, which is copyright
   Fabrice Bellard, licensed under the LGPL.  It is used with
   permission.  
*/

typedef UChar uint8_t;
typedef UInt  uint32_t;

#define CC_O CC_MASK_O
#define CC_P CC_MASK_P
#define CC_C CC_MASK_C


static const uint8_t parity_table[256] = {
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    CC_P, 0, 0, CC_P, 0, CC_P, CC_P, 0,
    0, CC_P, CC_P, 0, CC_P, 0, 0, CC_P,
};

/* n must be a constant to be efficient */
static inline int lshift(int x, int n)
{
    if (n >= 0)
        return x << n;
    else
        return x >> (-n);
}


#define PREAMBLE(__data_bits)						 \
   const UInt DATA_MASK 						 \
      = __data_bits==8 ? 0xFF : (__data_bits==16 ? 0xFFFF : 0xFFFFFFFF); \
   const UInt SIGN_MASK = 1 << (__data_bits - 1);                        \
   const UInt CC_DST = cc_dst;						 \
   const UInt CC_SRC = cc_src


#define ACTIONS_ADD(DATA_BITS,DATA_TYPE)		\
   {								\
      PREAMBLE(DATA_BITS);					\
      int cf, pf, af, zf, sf, of;				\
      int src1, src2;						\
      src1 = CC_SRC;						\
      src2 = CC_DST - CC_SRC;					\
      cf = (DATA_TYPE)CC_DST < (DATA_TYPE)src1;			\
      pf = parity_table[(uint8_t)CC_DST];			\
      af = (CC_DST ^ src1 ^ src2) & 0x10;			\
      zf = ((DATA_TYPE)CC_DST == 0) << 6;			\
      sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;		\
      of = lshift((src1 ^ src2 ^ -1) & (src1 ^ CC_DST), 	\
                  12 - DATA_BITS) & CC_O;			\
      return cf | pf | af | zf | sf | of;			\
   }

#define ACTIONS_ADC(DATA_BITS,DATA_TYPE)	\
{							\
      PREAMBLE(DATA_BITS);				\
    int cf, pf, af, zf, sf, of;				\
    int src1, src2;					\
    src1 = CC_SRC;					\
    src2 = CC_DST - CC_SRC - 1;				\
    cf = (DATA_TYPE)CC_DST <= (DATA_TYPE)src1;		\
    pf = parity_table[(uint8_t)CC_DST];			\
    af = (CC_DST ^ src1 ^ src2) & 0x10;			\
    zf = ((DATA_TYPE)CC_DST == 0) << 6;			\
    sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;		\
    of = lshift((src1 ^ src2 ^ -1) & (src1 ^ CC_DST), 	\
                 12 - DATA_BITS) & CC_O;		\
    return cf | pf | af | zf | sf | of;			\
}

#define ACTIONS_SUB(DATA_BITS,DATA_TYPE)			   \
   {									   \
      PREAMBLE(DATA_BITS);						   \
      int cf, pf, af, zf, sf, of;					   \
      int src1, src2;							   \
      src1 = CC_DST + CC_SRC;						   \
      src2 = CC_SRC;							   \
      cf = (DATA_TYPE)src1 < (DATA_TYPE)src2;				   \
      pf = parity_table[(uint8_t)CC_DST];				   \
      af = (CC_DST ^ src1 ^ src2) & 0x10;				   \
      zf = ((DATA_TYPE)CC_DST == 0) << 6;				   \
      sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;			   \
      of = lshift((src1 ^ src2) & (src1 ^ CC_DST), 12 - DATA_BITS) & CC_O; \
      return cf | pf | af | zf | sf | of;				   \
   }

#define ACTIONS_SBB(DATA_BITS,DATA_TYPE)					\
{										\
    PREAMBLE(DATA_BITS);							\
    int cf, pf, af, zf, sf, of;							\
    int src1, src2;								\
    src1 = CC_DST + CC_SRC + 1;							\
    src2 = CC_SRC;								\
    cf = (DATA_TYPE)src1 <= (DATA_TYPE)src2;					\
    pf = parity_table[(uint8_t)CC_DST];						\
    af = (CC_DST ^ src1 ^ src2) & 0x10;						\
    zf = ((DATA_TYPE)CC_DST == 0) << 6;						\
    sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;					\
    of = lshift((src1 ^ src2) & (src1 ^ CC_DST), 12 - DATA_BITS) & CC_O;	\
    return cf | pf | af | zf | sf | of;						\
}

#define ACTIONS_LOGIC(DATA_BITS,DATA_TYPE)	\
   {							\
      PREAMBLE(DATA_BITS);				\
      int cf, pf, af, zf, sf, of;			\
      cf = 0;						\
      pf = parity_table[(uint8_t)CC_DST];		\
      af = 0;						\
      zf = ((DATA_TYPE)CC_DST == 0) << 6;		\
      sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;	\
      of = 0;						\
      return cf | pf | af | zf | sf | of;		\
   }

#define ACTIONS_INC(DATA_BITS,DATA_TYPE)	\
{							\
    PREAMBLE(DATA_BITS);				\
    int cf, pf, af, zf, sf, of;				\
    int src1, src2;					\
    src1 = CC_DST - 1;					\
    src2 = 1;						\
    cf = CC_SRC;					\
    pf = parity_table[(uint8_t)CC_DST];			\
    af = (CC_DST ^ src1 ^ src2) & 0x10;			\
    zf = ((DATA_TYPE)CC_DST == 0) << 6;			\
    sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;		\
    of = ((CC_DST & DATA_MASK) == SIGN_MASK) << 11;	\
    return cf | pf | af | zf | sf | of;			\
}

#define ACTIONS_DEC(DATA_BITS,DATA_TYPE)			\
{									\
  PREAMBLE(DATA_BITS);							\
  int cf, pf, af, zf, sf, of;						\
  int src1, src2;							\
  src1 = CC_DST + 1;							\
  src2 = 1;								\
  cf = CC_SRC;								\
  pf = parity_table[(uint8_t)CC_DST];					\
  af = (CC_DST ^ src1 ^ src2) & 0x10;					\
  zf = ((DATA_TYPE)CC_DST == 0) << 6;					\
  sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;				\
  of = ((CC_DST & DATA_MASK) == ((uint32_t)SIGN_MASK - 1)) << 11;	\
  return cf | pf | af | zf | sf | of;					\
}

#define ACTIONS_SHL(DATA_BITS,DATA_TYPE)		\
{								\
  PREAMBLE(DATA_BITS);						\
    int cf, pf, af, zf, sf, of;					\
    cf = (CC_SRC >> (DATA_BITS - 1)) & CC_C;			\
    pf = parity_table[(uint8_t)CC_DST];				\
    af = 0; /* undefined */					\
    zf = ((DATA_TYPE)CC_DST == 0) << 6;				\
    sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;			\
    /* of is defined if shift count == 1 */			\
    of = lshift(CC_SRC ^ CC_DST, 12 - DATA_BITS) & CC_O;	\
    return cf | pf | af | zf | sf | of;				\
}

#define ACTIONS_SAR(DATA_BITS,DATA_TYPE)		\
{								\
    PREAMBLE(DATA_BITS);  					\
    int cf, pf, af, zf, sf, of;					\
    cf = CC_SRC & 1;						\
    pf = parity_table[(uint8_t)CC_DST];				\
    af = 0; /* undefined */					\
    zf = ((DATA_TYPE)CC_DST == 0) << 6;				\
    sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;			\
    /* of is defined if shift count == 1 */			\
    of = lshift(CC_SRC ^ CC_DST, 12 - DATA_BITS) & CC_O; 	\
    return cf | pf | af | zf | sf | of;				\
}

/* ROL: cf' = lsb(result).  of' = msb(result) ^ lsb(result). */
/* DST = result, SRC = old flags */
#define ACTIONS_ROL(DATA_BITS,DATA_TYPE)		\
{								\
    PREAMBLE(DATA_BITS);					\
    int fl 							\
       = (CC_SRC & ~(CC_O | CC_C))				\
         | (CC_C & CC_DST)			\
         | (CC_O & (lshift(CC_DST, 11-(DATA_BITS-1)) 		\
                    ^ lshift(CC_DST, 11)));	\
    return fl;							\
}

/* ROR: cf' = msb(result).  of' = msb(result) ^ msb-1(result). */
/* DST = result, SRC = old flags */
#define ACTIONS_ROR(DATA_BITS,DATA_TYPE)		\
{								\
    PREAMBLE(DATA_BITS);					\
    int fl 							\
       = (CC_SRC & ~(CC_O | CC_C))				\
         | (CC_C & (CC_DST >> (DATA_BITS-1)))			\
         | (CC_O & (lshift(CC_DST, 11-(DATA_BITS-1)) 		\
                    ^ lshift(CC_DST, 11-(DATA_BITS-1)+1)));	\
    return fl;							\
}

#define ACTIONS_MUL(DATA_BITS,DATA_UTYPE,DATA_S2TYPE)			\
{									\
    PREAMBLE(DATA_BITS);						\
    int cf, pf, af, zf, sf, of;						\
    DATA_UTYPE  r  = ((DATA_UTYPE)CC_SRC)  * ((DATA_UTYPE)CC_DST);	\
    DATA_S2TYPE rr = ((DATA_S2TYPE)CC_SRC) * ((DATA_S2TYPE)CC_DST);	\
    cf = (r == (DATA_UTYPE)(rr >>/*signed*/ DATA_BITS));	       	\
    pf = parity_table[(uint8_t)r];					\
    af = 0; /* undefined */						\
    zf = (r == 0) << 6;							\
    sf = lshift(r, 8 - DATA_BITS) & 0x80;				\
    of = cf << 11;							\
    return cf | pf | af | zf | sf | of;					\
}


/* CALLED FROM GENERATED CODE */
/*static*/ UInt calculate_eflags_all ( UInt cc_op, UInt cc_src, UInt cc_dst )
{
   switch (cc_op) {
      case CC_OP_COPY:
         return cc_src & (CC_MASK_O | CC_MASK_S | CC_MASK_Z 
                          | CC_MASK_A | CC_MASK_C | CC_MASK_O);

      case CC_OP_ADDB:   ACTIONS_ADD( 8,  UChar  );
      case CC_OP_ADDW:   ACTIONS_ADD( 16, UShort );
      case CC_OP_ADDL:   ACTIONS_ADD( 32, UInt   );

      case CC_OP_ADCB:   ACTIONS_ADC( 8,  UChar  );
      case CC_OP_ADCW:   ACTIONS_ADC( 16, UShort );
      case CC_OP_ADCL:   ACTIONS_ADC( 32, UInt   );

      case CC_OP_SUBB:   ACTIONS_SUB(  8, UChar  );
      case CC_OP_SUBW:   ACTIONS_SUB( 16, UShort );
      case CC_OP_SUBL:   ACTIONS_SUB( 32, UInt   );

      case CC_OP_SBBB:   ACTIONS_SBB(  8, UChar  );
      case CC_OP_SBBW:   ACTIONS_SBB( 16, UShort );
      case CC_OP_SBBL:   ACTIONS_SBB( 32, UInt   );

      case CC_OP_LOGICB: ACTIONS_LOGIC(  8, UChar  );
      case CC_OP_LOGICW: ACTIONS_LOGIC( 16, UShort );
      case CC_OP_LOGICL: ACTIONS_LOGIC( 32, UInt   );

      case CC_OP_INCB:   ACTIONS_INC(  8, UChar  );
      case CC_OP_INCW:   ACTIONS_INC( 16, UShort );
      case CC_OP_INCL:   ACTIONS_INC( 32, UInt   );

      case CC_OP_DECB:   ACTIONS_DEC(  8, UChar  );
      case CC_OP_DECW:   ACTIONS_DEC( 16, UShort );
      case CC_OP_DECL:   ACTIONS_DEC( 32, UInt   );

      case CC_OP_SHLB:   ACTIONS_SHL(  8, UChar  );
      case CC_OP_SHLW:   ACTIONS_SHL( 16, UShort );
      case CC_OP_SHLL:   ACTIONS_SHL( 32, UInt   );

      case CC_OP_SARB:   ACTIONS_SAR(  8, UChar  );
      case CC_OP_SARW:   ACTIONS_SAR( 16, UShort );
      case CC_OP_SARL:   ACTIONS_SAR( 32, UInt   );

      case CC_OP_ROLB:   ACTIONS_ROL(  8, UChar  );
      case CC_OP_ROLW:   ACTIONS_ROL( 16, UShort );
      case CC_OP_ROLL:   ACTIONS_ROL( 32, UInt   );

      case CC_OP_RORB:   ACTIONS_ROR(  8, UChar  );
      case CC_OP_RORW:   ACTIONS_ROR( 16, UShort );
      case CC_OP_RORL:   ACTIONS_ROR( 32, UInt   );

      case CC_OP_MULL:   ACTIONS_MUL( 32, UInt, Long );

      default:
         /* shouldn't really make these calls from generated code */
         vex_printf("calculate_eflags_all( %d, 0x%x, 0x%x )\n",
                    cc_op, cc_src, cc_dst );
         vpanic("calculate_eflags_all");
   }
}

/* CALLED FROM GENERATED CODE */
static UInt calculate_eflags_c ( UInt cc_op, UInt cc_src, UInt cc_dst )
{
   return calculate_eflags_all(cc_op,cc_src,cc_dst) & CC_MASK_C;
}


/* The only exported function. */

Addr64 x86guest_findhelper ( Char* function_name )
{
   if (vex_streq(function_name, "calculate_eflags_all"))
      return (Addr64)(& calculate_eflags_all);
   if (vex_streq(function_name, "calculate_eflags_c"))
      return (Addr64)(& calculate_eflags_c);
   vex_printf("\nx86 guest: can't find helper: %s\n", function_name);
   vpanic("x86guest_findhelper");
}


/*---------------------------------------------------------------*/
/*--- end                                guest-x86/ghelpers.c ---*/
/*---------------------------------------------------------------*/
